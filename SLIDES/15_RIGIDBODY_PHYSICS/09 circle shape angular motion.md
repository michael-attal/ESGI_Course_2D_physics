

# Introduction


Okay, so here we are, we spoke a lot about these ideas of rotation, this angular motion, and we are going to just start typing everything that we saw in the slides, just translate here into our existing source code. So let's not waste any time, let's just go ahead and do what we need to do.



# Linear vs Angular Motion

So right here, we know that this thing right here is linear motion, these ideas of position velocity and acceleration, and we know that we're going to have something here, very singular, and this is going to be angular motion, and we're going to have, well, three floating point variables, float, float, float, and float, and we're going to have instead of position, now we want that rotation angle, right? So this is going to be, I'm going to call this rotation, instead of simply velocity, this is going to be angular velocity, and instead of simply acceleration, we're going to have angular acceleration, and that should do the job. So positions of velocity and acceleration, these are linear movement, and this thing is angular movement.

# Forces and Torque

And we also have a couple of extra things. So before we had these ideas of force, so here we're going to have forces and for correct, so I'm going to have still the sum of the forces, those linear forces, but I'm going to have something called the sum of the torque that we are applying in this object at this physics step, right here, right in this frame, and let's see what else we're going to have these ideas of mass and momentum of inertia. So we're still going to have the mass and the inverse of the mass, but we're also going to have now the moment of inertia of this object, and you will see that most physics engines, if you look at the source code of box to D or chipmunk to D, they would declare an uppercase I for the moment of inertia, and of course, an inverse of the moment of inertia. So we are going to have these two things.

# Mass and Inertia Management

You will see that some physics engines, they just store the inverse of the mass, for example, and the inverse of the moment of inertia. I am storing the actual mass and the inverse of the mass, and I'm also storing the actual moment of inertia and the inverse moment of inertia. It's just a judgment call that I did, I am willing to store all these values inside my body object.

# Shape Initialization

There we go. Let's see what else we have. Well, here we have this shape, so this is going to be a pointer to the body shape, right? So the shape or the geometry, how we want to call it, this rigid body, and I am initializing with a no pointer. Well, since this is C++, you will see that sometimes I have this C program as mine set, but since this is actually C++, we have no PTR, identified for no pointer. So I'm just replacing that no by no PTR, pretty much the same thing, right?

# Constructor Initialization

So let's see what else I need to change the constructor later, so we're going to look at implementation very soon. Adforces and clearforces, let me just declare something called AdPork, which I'm going to receive the torque that I want to apply, and also besides clearforces, I have now clear torque, correct? Nothing you hear, so clear, torque, to clear all the torque that is being applied at this object, at this frame, at a this physics step, let's see if I need something else, huh, integrate.

# Integration Functions

So besides integrate, I'm going to separate into two functions. So I'm going to have an integrate linear, and I'm going to have an integrate angular. And then we're going to have to see what goes inside each one. But I think the prototype of my body object is going to be this thing right here. So, well, very good, let's just go to our body.cppm and just save everything and go to body.cppm. And let's start implement this small change here.

# Constructor Details

Let's see what we need, right? So a couple of errors, let's start by the construct. The constructor we are initializing a couple of things, let me really polish this constructor because besides initializing the shape with a clone of my parameter shape, the position recedes the x and y parameter, let me initialize the other things that we have. So this velocity, which we didn't initialize before, comes from a vector to zero zero. So I just reset the velocity, just to make sure, right, acceleration the same thing. And from that to zero zero, when we start our body. So the velocity acceleration position, let's just initialize the angular property. So this rotation is zero point zero, radians, this angular velocity is zero point zero, this angular acceleration, because it's zero point zero. So just resetting everything at the start of our body when we create our body object. And let's not forget this, some forces equals the back to zero zero. And now we have the sum of the torque. So this sum torque equals to zero point zero, because it is a floating point number.

# Mass and Inverse Initialization

Right, let's see what else do we need here. So we are initializing the mass, but also the inverse of the mass, based on that mass parameter. And I'm going to have something very similar here. So let me just e and this one, because I need to talk about the inverse of my moment of inertia. But the moment of inertia, e comes from the shape, moment of inertia, times the rigid body's mass. Remember how we spoke about this in the previous session? So this is going to come from shape, get moment of inertia, and we are going to have to create this method, times this mass, or just simply mass. And then I can go ahead and pretty much just paste here, the logic that says, if the moment of inertia is different than zero, then the inverse of the moment of inertia comes from the inverse of the moment of inertia, else the inverse of moment of inertia just assumes zero.

# Shape Inertia and Implementation

Because this makes sense. So right here on this area is where I set the inverse of the mass of my object. And then right here is where I calculate the moment of inertia based on the shape, moment of inertia, times the mass of my rigid body. And then I proceed to set the inverse moment of inertia in case we can do that, which is basic to just saying 1.0 divided by the moment of inertia of my object. And I think that's it. So we are going to have to go and inside my shape, right? Each one of those shapes, the circle shape, the box shape, the polygon shape. We have to go and create this gap moment of inertia method. And this is a to do that we have to do very soon inside the shape objects.

# Torque Management and Integration

Let's see what else body, the leap shape, add force that we're going to have, decide the add force we're going to have for, right? So we can add a torque, add torque that receives just changing side to parentheses. We have to receive a float torque. And then we just add to some fork plus equals torque. Is this enough? Clear forces just resets the forces and I'm going to yank and paste this thing right here, which is going to be my clear torque, which goes there and says that the sum of the torque is now back to zero point zero. A good so far, everyone falling along, nothing to complicated just transferring all those ideas of linear force, linear mass, now into moment of inertia, torque, and this angular motion.

# Angular Integration Logic

And I think the last thing that we have to do is we have to separate, right? Before we have the integrate, the linear, which was these ideas of coming here and finding the linear acceleration, linear velocity, changing the linear position and clearing the forces. We're going to have to have something very similar. I'm just yank again this thing and we are going to have a new integrate, which is going to be the integrate angular. And we have to change a couple things. So integrate angular, we have to work with those angular attributes, right? So let's just see here, we have to find the angular acceleration based on the torque that is being applied. And not the mass, but the moment of inertia. This means that instead of acceleration, this is angular acceleration is equal to the sum of the torque, multiply by the inverse moment of inertia, inverse upper case i. We see exactly the same thing we had before for linear movement, we just use now this angular properties. The second one we have to find the angular velocity by integrating the angular acceleration. So let's just see what we need here. We have to integrate the angular acceleration to find the new angular velocity. And that is as is the same angular velocity angular acceleration times dt or delta time. And this one right here we have to integrate the angular velocity now to find the new not the position, but the new angle right is rotation angle. So not position, rotation plus equals angular velocity times delta time. And here we have to just clear all the torque, acting on the object before the next physics step. Absolutely, just clear torque. And that should be it for our integration methods, integrate linear and integrate angular.

# Shape Inertia Implementation

Let me just say everything. And let me just quickly change the shape, right to include that idea of the gap moment of inertia on line 20 that we have to initialize. So each one of those shapes we have a specific formula for the moment of inertia. Let's open this thing. I think we have to change the prototype, so shape dot H first. And this is as simple as saying that our shape we're going to have a virtual method that we have to override in each one of the children classes. So virtual float. Get a moment of inertia. I'm going to say that this thing is going to be a const because it's not going to change anything, just calculate and return a float. So get moment of inertia, which we're going to have to override in the circle shape, in the polygon shape.

# Circle and Box Inertia

So we're going to have to override something which is float, get moment of inertia, const over right. C++ expects us to come here and manually say that we are overriding this thing from the parent class. And let me just yank this one and paste on the polygon shape, meaning that the polygon shape will have a gap moment of inertia method as well. And you know it, same thing for my box shape. My box shape will also get its own moment of inertia. Because each one of the shapes they have a specific formula, right? How we saw on Wikipedia. So all we have to do is say that everything, go to our shape dot cp and calculate the correct moment of inertia for the box for the circle for the polygon.

# Circle Formula

So let's just see what we have here. The circle shape right about here. I am going to say that we have a float circle shape, get moment of inertia that this is not thing. It is a const and I'm going to return that formula. And I am not going to write that formula from scratch. I already have it here in a VIM buffer. I'm just going to paste it. And here it is. So for my circle, moment of inertia, for solid circles, the moment of inertia is one half times the radius squared. And I am also saying that this steel needs to be multiplied by the rated body's mass, right? This thing is just a shape part of the calculation, which is 0.5, right? One half times radius times radius squared. But this thing right here, we still need to go and in the body constrictor, we are multiplying by the rigid body's mass.

# Box Formula

A good, this is the moment of inertia of a solid circle. And we are going to have also a moment of inertia for a polygon shape and a moment of inertia for a box shape. We saw the box shape before, remember, I think we saw it on Wikipedia that formula. So I'm going to have something called float box shape, get moment of inertia, const and we're going to implement this thing again, same thing. I'm just going to paste this from a VIM buffer that I already have here in my clipboard. Here we go. So for a rectangle, the moment of inertia is 1 divided by 12 times the width squared plus the height of the box squared. And again, this steel needs to be multiplied by the rigid body's mass. But this is our calculation for the box, right? The part of the box, which is responsible for the shape, which is 0.083. So 1 divided by 12 times the width squared plus the height of the box squared.

# Polygon Formula (To-Do)

I think this makes sense. And we're going to say, okay Gustavo, what about the polygon? Let me just get this one. Come here to my polygon shape. We're going to have something right here, which is the polygon shape. So polygon shape, get moment of inertia, which we're going to have to implement. So this thing right here, we're going to have to do. But let me just come here and say return 0.0. Now just so we don't have a syntax error in our code. So I just have to go and we're going to learn later how we go and we break the polygon and calculate the moment of inertia of each one of the triangles inside my polygon. This thing we're going to have to learn to do in the future, right? So I'm just going to have to leave this to do here for us to remember, right? For me to remember to go and implement this in the near future.

# Testing Angular Rotation

But I think having the circle get moment of inertia right here and having the box shape, moment of inertia here, I think this is enough for us to experiment with circles, boxes, see if we can rotate the shapes. But for now, we know that we are basically just playing around with circle shapes, right? We are basically just getting our feet wet, just learning about circles. But very soon we are going to start adding boxes, we're going to start adding convex polygons to our scene and then we're going to have to come back here and learn how to implement this moment of inertia of polygon.

# Testing and Debugging

So let me just say everything, how about we come here and we just test what we have so far. Let's see if we have any mistakes. Body integrate. So in our application, let's see we are calling the integrate, which doesn't exist anymore. Now it's integrate linear and integrate angular. So let's just quickly come here. Let's open our application of CPP and we have integrate right here online 69 distinct becomes integrate linear and we also have to integrate both linear and angular attributes of our body. And that should be let's find this again. Let's see how we are. Whoops. Linker error problem, right? So it says we table for shape. I'm using the table which I mean first knowing line virtual member. Ooh, I think I forgot to make the gap moment of inertia pure virtual in the shape class. Was that it? Let's see. So up here in my shape parent class. Yep, that's it. So online 17, this thing has to be a pure virtual method. It goes really. I think that was it. Come on, come on, come on, let's see. Beautiful. So apparently no syntax errors. Let's go ahead and see if we can apply a torque to our circle and see if it starts rotating or gaining this angular acceleration.

# Applying Torque and Observing Rotation

Right? So let's see what we can do here. Now in my application.cpp right about here. So here is where we apply forces to the body. I want to apply besides the way force. I want to apply. Let's just create something called torque. And let me just say that torque is, I don't know, 20. Just a number. Let's see if this is too big or too small. And then I can say my body, I can add a torque passing that float torque. Again, the units of measurement of this 20 still not clear for us, right? This is just a magic number. Let's just see what happens. So this is at torque. But there is just one special case that we have to remove. Remember down there in our render function. This thing right here before, we were passing this angle variable that created above. Right? So I don't want this thing anymore. Right? This static float angle that I had before is no more. I don't have to increment this thing again. And right here, I will have to remove this angle and this thing right here. Where is the angle? What is the rotation angle of my rigid body? Well, it is inside. Body. Rotation. Right? This is the rotation angle that we have.

# Verification and Result

So let's see if this works as you say everything. Compare everything. Do everything. Again, and let's see how this looks. So I hope to our bodies slowly rotating. Well, it's there. It's slowly but it is accelerating. Right? This angular acceleration is happening. If you really pay attention there at the line of that circle. So we are starting to accelerate the rotation more and more and more velocity. There we go. So we start to rotate more and more and more and more hopefully. This is us applying a torque force. Again, that 20 floating point number that I'm applying. It's too small to be. We're going to have to make sense of this units of measurement that we're working with in terms of rating. That is rotation angle. But this is the proof that we are applying a torque force. The torque force is responsible for changing the angular acceleration and then based on that angular acceleration, we integrate the angular acceleration to find the new angular velocity. And then we integrate the angular velocity to find the new angle. I to find this new rotation angle of my circle in this case.

# Conclusion and Next Step

That's it. So everyone, I think this proofs that I wanted to show with this idea of rotation. Right? This angular movement, angular acceleration, angular, all these radians that we are changing in the rotation of our circle. I was tempted to go now and maybe try to think about collisions. But before I do that, how about we go and we try to render a box just because right? I just want to see if we can render this box polygon. Let's see if we can also rotate that box polygon and rotate all those vertices of the box. I think it's important for us to understand how we're going to work with this circles and box before we enter the collision. So I'm going to leave the collision part at the end of our course, right, which is basically the most complicated area where we have to detect the collision, check the collision, resolve that collision, apply impulses, etc. Let's just learn very quickly how we can go about drawing a box and also rotating that box. I want to rotate by this angular acceleration. I want to apply a torque and see that box rotate as well. So that is going to be our next task. It's going to be super simple, super quick. I just want to go learn how we can draw box and rotate that box around, move that box around. I think this is a good, simple task for the next video. So let's just go ahead and do exactly that.
